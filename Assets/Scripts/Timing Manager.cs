using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TimingManager : MonoBehaviour
{
    public List<GameObject> boxNoteList = new List<GameObject>();

    [SerializeField] Transform Center = null;
    [SerializeField] Transform[] timingRect = null;
    Vector2[] timingBoxs = null;
    

    
    void Start()
    {
        
        timingBoxs = new Vector2[timingRect.Length]; // new Vector2는 x y 좌표값 아닌가요??
     
       // Debug.Log(Center.transform.position.y);
        for(int i = 0; i < timingRect.Length; i++)
        {
            timingBoxs[i].Set(Center.position.y + timingRect[i].localScale.y / 2,
                              Center.position.y - timingRect[i].localScale.y / 2);

            // 반복문에서 timingRect의 배열 개수만큼 최솟값과 최댓값을 timingBoxs[i] 안에 저장 중
            // ex) timingBoxs[0] = (최솟값 (원래 좌표값이 음수이기 때문에 +가 최소),최댓값)
        }
        Debug.Log(timingBoxs[1].x);
        Debug.Log(timingBoxs[1].y);// 최솟값과 최댓값이 출력될 줄 알았으나 그대로 -4가 출력됨(?)
    }

    public void CheckTiming()
    {
        for (int i = 0; i < boxNoteList.Count; i++)
        {
            float t_notePosY = boxNoteList[i].transform.position.y;  // 리스트에 저장된 노트의 y좌표축 값
            for (int y = 0; y < timingBoxs.Length; y++) //timingBox의 Length는 timingRect 개수와 일치함
            {
                if (timingBoxs[y].y >= t_notePosY )
                // 필요한 조건문 : timingBox[y] = (최소x, 최대y)이기 때문에 최소 <= t_notePosY <= 최대로 설정할것
                {
                    Debug.Log("Hit" + y); //디버그 되는 y는 timingBoxs 안에 저장된 timingRect의 이름이어야 함
                    return;
                }
                //예상 필요 판정 조건
                //: perfectRect.y(최소 ,  최대) = t_notePosY =>  perfect
                // greatRect.y(최소, 최대) = t_notePosY && perfectRect.y != t_notePosY => great

            }
        }
        Debug.Log("Miss");
    }
   
}
